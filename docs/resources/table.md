---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "anaml_table Resource - terraform-provider-anaml"
subcategory: ""
description: |-
  Tables
  A Table represents a source of data for feature generation. A Table can be one of five types:
  External TableView TableJoin TablePivot TableEvent Store Table
  External Tables
  An External Table is the representation of a source table. Therefore you have to specify the
  underlying data sources that the table is stored in.
  View Tables
  A View Table is a pre-defined query over one or more other Root Tables or View Tables.
  They function in the same way as views in relational databases. They can be used to transform
  or join tables using arbitary SQL.
  When to use View Tables and when to use Features?
  In general, features should be used wherever possible to transform or aggregate columns as required.
  This allows for better documentation, re-use and collaboration of features as well as allowing
  for better optimise generation runs.
  View Tables are mainly useful for joining data on keys other than entity id's such as reference data lookups.
  Join Tables
  Join tables are similar to View tables, in that they perform operations other tables, but these perform
  time aware joins between events and dimensional tables, or dimensional and dimensional.
  Interestingly, Join tables perform efficient and correct joining of SCD2 tables with correctness properties
  which are challenging to achieve with SQL.
  Pivot Tables
  Pivot Tables allow features to be re-keyed to different entities.
  This can be very useful, as often in business applications one may have different levels of entity; for example,
  plans and customers. Data may be organised and keyed by plan, and some attributes and campaigns may target plans;
  but also, plans are owned by customers, and when doing analysis on customers, knowing information about their
  plans is crucial.
  Pivot tables help to solve this issue by allowing features which are written for plans to be repurposed at the
  customer level.
  When construcing a pivot table, one needs to specify an entity mapping, which shows how to go from plans to
  customers (this uses a feature query which outputs the customer for a particular plan), and the plan level
  features which are to be aggregated to the customer.
  Usually, the features one writes on a pivot table are simple aggregations, such as number of plans (count) or
  average of some column with some filtering. Day and Row windows are not required.
  Event Store Tables
  Event store tables are a robust store of tables backed and managed by Anaml. Usually, these will ingest data
  from a Kafka topic, and describe mappings to events.
  Table definitions for event store tables reference a managed event store, and the entity for which the data
  should be interpreted.
  Time and Entity Descriptions
  To be used in feature generation a Table must have one or more Entities as well as the semantics
  for how to interpret timestamp columns for the table.
  To achieve this, one should use one of the 'event', 'scd2', or 'pointintime' blocks (as described below).
  All of these blocks are able to accept a map of entities can be used as keys for this table in feature
  generation, as well as their timestamp columns.
---

# anaml_table (Resource)

# Tables

A Table represents a source of data for feature generation. A Table can be one of five types:

- External Table
- View Table
- Join Table
- Pivot Table
- Event Store Table

### External Tables

An External Table is the representation of a source table. Therefore you have to specify the
underlying data sources that the table is stored in.

### View Tables

A View Table is a pre-defined query over one or more other Root Tables or View Tables.
They function in the same way as views in relational databases. They can be used to transform
or join tables using arbitary SQL.

**When to use View Tables and when to use Features?**

In general, features should be used wherever possible to transform or aggregate columns as required.
This allows for better documentation, re-use and collaboration of features as well as allowing
for better optimise generation runs.

View Tables are mainly useful for joining data on keys other than entity id's such as reference data lookups.


### Join Tables

Join tables are similar to View tables, in that they perform operations other tables, but these perform
time aware joins between events and dimensional tables, or dimensional and dimensional.

Interestingly, Join tables perform efficient and correct joining of SCD2 tables with correctness properties
which are challenging to achieve with SQL.


### Pivot Tables

Pivot Tables allow features to be re-keyed to different entities.

This can be very useful, as often in business applications one may have different levels of entity; for example,
plans and customers. Data may be organised and keyed by plan, and some attributes and campaigns may target plans;
but also, plans are owned by customers, and when doing analysis on customers, knowing information about their
plans is crucial.

Pivot tables help to solve this issue by allowing features which are written for plans to be repurposed at the
customer level.

When construcing a pivot table, one needs to specify an entity mapping, which shows how to go from plans to
customers (this uses a feature query which outputs the customer for a particular plan), and the plan level
features which are to be aggregated to the customer.

Usually, the features one writes on a pivot table are simple aggregations, such as number of plans (count) or
average of some column with some filtering. Day and Row windows are not required.


### Event Store Tables

Event store tables are a robust store of tables backed and managed by Anaml. Usually, these will ingest data
from a Kafka topic, and describe mappings to events.

Table definitions for event store tables reference a managed event store, and the entity for which the data
should be interpreted.


## Time and Entity Descriptions

To be used in feature generation a Table must have one or more Entities as well as the semantics
for how to interpret timestamp columns for the table.

To achieve this, one should use one of the 'event', 'scd2', or 'point_in_time' blocks (as described below).

All of these blocks are able to accept a map of entities can be used as keys for this table in feature
generation, as well as their timestamp columns.



<!-- schema generated by tfplugindocs -->
## Schema

### Required

- **name** (String) Name of the table in Anaml.

### Optional

- **attribute** (Block Set) Attributes (key value pairs) to attach to the object (see [below for nested schema](#nestedblock--attribute))
- **description** (String)
- **domain_modelling** (Block List, Max: 1) Model dimensions and measures for tables, and add virtual columns as simple SQL expressions (see [below for nested schema](#nestedblock--domain_modelling))
- **event** (Block List, Max: 1) This table contains events which occurred at a particular time (see [below for nested schema](#nestedblock--event))
- **event_store** (Block List, Max: 1) Information for how to interpret an Event store topic as a Table (see [below for nested schema](#nestedblock--event_store))
- **id** (String) The ID of this resource.
- **join** (Block List, Max: 1) Create a Join table, which performs time aware joins between tables. (see [below for nested schema](#nestedblock--join))
- **labels** (Set of String) Labels to attach to the object
- **pivot** (Block List, Max: 1) Create a Pivot table, which allows features to be aggregated for different entities. (see [below for nested schema](#nestedblock--pivot))
- **point_in_time** (Block List, Max: 1) This table is a Dimensional table with updates at particular times (see [below for nested schema](#nestedblock--point_in_time))
- **scd2** (Block List, Max: 1) This table is a Slowly Changing Dimensional table (see [below for nested schema](#nestedblock--scd2))
- **source** (Block List, Max: 1) Source information for a Root table. (see [below for nested schema](#nestedblock--source))
- **view** (Block List, Max: 1) Define a View table using sources and an expression (see [below for nested schema](#nestedblock--view))

<a id="nestedblock--attribute"></a>
### Nested Schema for `attribute`

Required:

- **key** (String)

Optional:

- **value** (String)


<a id="nestedblock--domain_modelling"></a>
### Nested Schema for `domain_modelling`

Optional:

- **base** (Block List) An existing column to annotate (see [below for nested schema](#nestedblock--domain_modelling--base))
- **virtual** (Block List) Dimensions tables to join to. (see [below for nested schema](#nestedblock--domain_modelling--virtual))

<a id="nestedblock--domain_modelling--base"></a>
### Nested Schema for `domain_modelling.base`

Required:

- **name** (String) Name of the Table

Optional:

- **description** (String)
- **dimension** (Block List, Max: 1) (see [below for nested schema](#nestedblock--domain_modelling--base--dimension))
- **measure** (Block List, Max: 1) (see [below for nested schema](#nestedblock--domain_modelling--base--measure))

<a id="nestedblock--domain_modelling--base--dimension"></a>
### Nested Schema for `domain_modelling.base.dimension`

No fields are necessary

<a id="nestedblock--domain_modelling--base--measure"></a>
### Nested Schema for `domain_modelling.base.measure`

Optional:

- **units** (String) Units for the measure



<a id="nestedblock--domain_modelling--virtual"></a>
### Nested Schema for `domain_modelling.virtual`

Required:

- **expression** (String) Name of the Table
- **name** (String) Name of the Table

Optional:

- **description** (String)
- **dimension** (Block List, Max: 1) (see [below for nested schema](#nestedblock--domain_modelling--virtual--dimension))
- **measure** (Block List, Max: 1) (see [below for nested schema](#nestedblock--domain_modelling--virtual--measure))

<a id="nestedblock--domain_modelling--virtual--dimension"></a>
### Nested Schema for `domain_modelling.virtual.dimension`

No fields are necessary

<a id="nestedblock--domain_modelling--virtual--measure"></a>
### Nested Schema for `domain_modelling.virtual.measure`

Optional:

- **units** (String) Units for the measure




<a id="nestedblock--event"></a>
### Nested Schema for `event`

Required:

- **entities** (Map of String)
- **timestamp_column** (String)

Optional:

- **timezone** (String)


<a id="nestedblock--event_store"></a>
### Nested Schema for `event_store`

Required:

- **entity** (String)
- **store** (String)
- **topic** (String)


<a id="nestedblock--join"></a>
### Nested Schema for `join`

Required:

- **table** (String) The root tables on the Left of the Join.

Optional:

- **joins** (List of String) Dimensions tables to join to.


<a id="nestedblock--pivot"></a>
### Nested Schema for `pivot`

Required:

- **entity_mapping** (String)
- **features** (List of String) Features to be included in this pivot table


<a id="nestedblock--point_in_time"></a>
### Nested Schema for `point_in_time`

Required:

- **entities** (Map of String)
- **primary_key** (String)
- **timestamp_column** (String)

Optional:

- **timezone** (String)


<a id="nestedblock--scd2"></a>
### Nested Schema for `scd2`

Required:

- **entities** (Map of String)
- **from_column** (String)
- **primary_key** (String)
- **valid_to_column** (String)

Optional:

- **timezone** (String)


<a id="nestedblock--source"></a>
### Nested Schema for `source`

Required:

- **source** (String)

Optional:

- **folder** (String)
- **table_name** (String)
- **topic** (String)


<a id="nestedblock--view"></a>
### Nested Schema for `view`

Required:

- **expression** (String) Expression for a View table.
- **sources** (List of String) Tables upon which this View is created


